<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo部署方案</title>
      <link href="/2023/06/25/hexo%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
      <url>/2023/06/25/hexo%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo部署方案"><a href="#Hexo部署方案" class="headerlink" title="Hexo部署方案"></a>Hexo部署方案</h2><h4 id="1-注册Github账号创建个人仓库"><a href="#1-注册Github账号创建个人仓库" class="headerlink" title="1.注册Github账号创建个人仓库"></a>1.注册Github账号创建个人仓库</h4><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93New">https://github.com/，新建一个项目仓库New</a> repository，如下所示：</p><p>要创建一个和你用户名相同的仓库，后面加.[<a href="http://github.io,只有这样,将来要部署到github/">http://github.io，只有这样，将来要部署到GitHub</a> page的时候，才会被识别，也就是<a href="http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://gaoziman.github.io">http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://gaoziman.github.io</a></p><h4 id="2-生成SSH添加到GitHub"><a href="#2-生成SSH添加到GitHub" class="headerlink" title="2.生成SSH添加到GitHub"></a>2.生成SSH添加到GitHub</h4><p>生成SSH添加到GitHub，连接Github与本地。<br>右键打开git bash，然后输入下面命令：</p><p><code>git config --global user.name &quot;yourname&quot;</code><br><code>git config --global user.email &quot;youremail&quot;</code><br>1<br>2<br>注意：第一次使用git后需要将用户名和邮箱进行初始化</p><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。例如我的：</p><p>git config –global user.name “gaiolan”<br>git config –global user.email “<a href="mailto:&#50;&#x39;&#x34;&#50;&#x38;&#57;&#x32;&#x36;&#x37;&#x35;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#50;&#x39;&#x34;&#50;&#x38;&#57;&#x32;&#x36;&#x37;&#x35;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a>“<br>1<br>2<br>可以用以下两条，检查一下你有没有输对</p><p>git config user.name<br>git config user.email<br>1<br>2<br>然后创建SSH,一路回车</p><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>ssh-keygen -t rsa -C “youremail”<br>1<br>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。或者git bash中输入</p><p>cat ~&#x2F;.ssh&#x2F;id_rsa.pub<br>1<br>将输出的内容复制到框中，点击确定保存。</p><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图：</p><p>在git bash输入ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;</a>，如果如下图所示，出现你的用户名，那就成功了。</p><ol start="6"><li>将hexo部署到GitHub<br>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</li></ol><p>修改最后一行的配置：</p><p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/gaoziman/gaoziman.github.io.git">https://github.com/gaoziman/gaoziman.github.io.git</a><br>  branch: master<br>1<br>2<br>3<br>4<br>repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><p>npm install hexo-deployer-git –save<br>1<br>然后</p><p>hexo clean<br>hexo generate<br>hexo deploy<br>1<br>2<br>3<br>其中 hexo clean清除了你之前生成的东西，也可以不加。 hexo generate顾名思义，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://yourname.github.io/">http://yourname.github.io</a> 这个网站看到你的博客了！！<br>————————————————<br>版权声明：本文为CSDN博主「Cisyam^」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_58608526/article/details/124652412">https://blog.csdn.net/qq_58608526/article/details/124652412</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/25/hello-world/"/>
      <url>/2023/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><strong>爱哲学</strong> <strong>爱生活</strong> <strong>爱编程</strong>的boy</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>守印录7.10</title>
      <link href="/2022/07/10/%E5%AE%88%E5%8D%B0%E5%BD%957-10/"/>
      <url>/2022/07/10/%E5%AE%88%E5%8D%B0%E5%BD%957-10/</url>
      
        <content type="html"><![CDATA[<p>1</p><h2 id="《守印录》"><a href="#《守印录》" class="headerlink" title="《守印录》"></a>《守印录》</h2><p>今天我所问的两个问题，先生的回答，让我明白了应该如何做，很有收获。首先就是这个每日的反思，我坚持写了三个多月，慢慢慢慢做着做着好像感觉没意义了，我这样做好像没有什么收获，于是就停了。我就这个问题请教了先生，我发现问题的关键不在于我得到了外在的什么，而是在与这个想放弃、想停下的念头对峙的本身，才是我应该真正做功夫的地方，而往往在这些地方，都是感觉最难的地方，是想做却不断给自己找借口不去做地方。读诗经也是如此，读来读取发现啥也没读到，于是也不想读了。先生举了一个例子，我一直以为做一件事，只要能够长期的坚持，就不会再断了。这里面有两个容易间断的地方，第一，是开始的时候，最初的那段时间，最难坚持。这个我深有体会，而万万没想到还有第二个地方，那就是做着做着感觉没了意义，自我放弃的时候，这个时候被叫做《黎明前的黑暗》，这个阶段也最容易放弃。听了先生的话，我知道我要该如何做了，没有意义本身，就是一件意义，就是我对峙自己私欲、小我。圣贤与普通人的差别就是在这个地方。只有真正敢于去对峙这些不敢、害怕、借口、不能。才能真正的成长，才是真正的意义。</p><p>2022 7-10 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 守印录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>守印录6-3.md</title>
      <link href="/2022/06/03/%E5%AE%88%E5%8D%B0%E5%BD%956-3/"/>
      <url>/2022/06/03/%E5%AE%88%E5%8D%B0%E5%BD%956-3/</url>
      
        <content type="html"><![CDATA[<h1 id="《守印录-6-3》"><a href="#《守印录-6-3》" class="headerlink" title="《守印录 6-3》"></a>《守印录 6-3》</h1><p>最近功夫又有所退转，反思和读书归其原因还是太相信自己，又去看了小说，想着看一会就停，没想到就停不下来了，良知指引了，反而反着它来，还是志不坚定，一点点诱惑心就不定了。外界环境，特殊情况的改变，也是私欲的一大诱因，我们不可能是在一个绝对理想的环境，有无奈，有身不由己。但是天理是不能动的啊。私欲发出来为什么可以战胜良知，究竟是不是真心为学，真的要好好反思。外界诱因也不是借口，战胜他们才是为学进步的关键。善有善报，恶有恶报，不是外在的 而是不按照良知指引，就会体现内心的不安，和对自己为学的质疑。得不是等来的，一定是要自己去克服困难，笃实、踏实的走在这条路上。经此而已。</p><p>当自勉之！</p><p>2022-6-3</p>]]></content>
      
      
      
        <tags>
            
            <tag> 格物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物2.17</title>
      <link href="/2022/02/17/%E6%A0%BC%E7%89%A92-17/"/>
      <url>/2022/02/17/%E6%A0%BC%E7%89%A92-17/</url>
      
        <content type="html"><![CDATA[<p>1</p><p>最近反思过多，可能会出现先生说的反思过度的情况，需要将前几天的反思自己体会，去践行，哪怕做不到也要比昨天更好。已经反思的问题，需要下功夫去做。不能光在嘴头上和笔头上。期待每天的心学课程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 内省 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物2.16</title>
      <link href="/2022/02/16/%E6%A0%BC%E7%89%A92-16/"/>
      <url>/2022/02/16/%E6%A0%BC%E7%89%A92-16/</url>
      
        <content type="html"><![CDATA[<p>s</p><h1 id="守印录2-16"><a href="#守印录2-16" class="headerlink" title="守印录2.16"></a><strong>守印录2.16</strong></h1><p>   今天的为学安排还算紧凑，专注了380分钟。手机的使用克制了许多，需注意的是，起床不要拖沓。睁眼就起来，多睡只会让精神更疲惫，要养成良好的生活习惯。其次，我发现，为学时会常常疲惫，有困意，这可能是晚上作息不规律睡太晚而造成的，精神不佳，自然容易会被私欲影响，在10点半之前必须放下手机入睡。</p><p>​君子欲讷于言而敏于行，这是我最容易出现的问题，这是为人处世的准则，言多必失，要少说空话，大话，说再多，也只是纸上谈兵。孔夫子也一向告诫弟子话应当少说。勿起义气之争，昨天还在与一个群里的人的争辩，今在此反思，这种行为所产生的原因，在于表现的心理，也就是爱名，这种行为很不可取，须时刻警醒自己，学问深的人，都是少说多做，不与人呈口色之争。同时也需亲贤人，远小人。双方争辩，此时出现一个第三方，他的话语却刺激二人争辩下去，这种人必须远离。</p><p>​今天话少了，事做多了，明显感受到内心的丰足，而不是如前几天的空虚。但在没有什么外在任务安排的时候，内心也很容易陷入娱乐，比如刚刚就刷视频刷了一个小时，这是我不齿的，既然知道克制不住，那就不去打开它。</p><p>​现在我更多的是事后反省，需要培养意念发动出，便致良知的功夫。为学的路很长，我愿行在路上！</p><p>​苟日新，又日新，日日新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 内省 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物2.15</title>
      <link href="/2022/02/15/%E6%A0%BC%E7%89%A92-15/"/>
      <url>/2022/02/15/%E6%A0%BC%E7%89%A92-15/</url>
      
        <content type="html"><![CDATA[<p>w</p><h1 id="守印录-2-15"><a href="#守印录-2-15" class="headerlink" title="守印录 2.15"></a><strong>守印录 2.15</strong></h1><p>​       我在思考，我光写下每天的反思，落不下去行动？真的有意义吗。就拿这一段时间分析下吧，八点回到家，九点半，才开始写下这篇反思，我的时间去哪了？一个半小时，全在手机上，我没有玩游戏，全在网络的聊天上，想到这，不禁沉默，我得到了什么？美其名曰，探讨人生，和别人交流，一会聊聊这，一会聊聊那，再和别人争辩争辩。实际上什么收获也没有，君子慎于言，那我这么做，为啥呢？是因为手机？我想不是，还是不要给自己找个外在的借口了，还是心不宁静，心不安定，不能做到不动心。手机是工具，可是到底是它在支配我？还是我在支配它？</p><p>​每天都在同样的事情上烦恼，在同样的心境下荒废时间。外界环境的一丢丢改变，就能让我平静的心，瞬间找个借口，悄悄的溜走。这个根，在哪里，不把这个根拔了，还是如此。信誓旦旦列好明天的计划，明天却依旧如旧。三天打鱼，两天晒网，无数无数个借口，无数无数个不为学的理由。你究竟是怎么了？</p><p>​一个念头，拿起手机，2秒，打开它，再放下，可能就是2个小时。什么可以给我力量，让我战胜它，唯有致良知，唯有立志。可这个志，为什么迟迟立不下来呢？难道真的是只有通过系统为学才能认识到吗？人的本源没有力量吗，离周五还有三天，这三天，我要尝试打败它。</p><p>​意外翻到铁旦老师的写的诗，质朴而真诚，诗里面，仿佛人变模糊了，又好像能透过它看到清澈的灵魂。没想到铁旦先生还有如此有趣的一面。我也决定，开始写诗，不管水平如何，就让它成为我生命中的一部分吧。</p><p>​晚安。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 内省 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物2.14</title>
      <link href="/2022/02/14/%E6%A0%BC%E7%89%A92-14/"/>
      <url>/2022/02/14/%E6%A0%BC%E7%89%A92-14/</url>
      
        <content type="html"><![CDATA[<p>s</p><h2 id="守印录2-14"><a href="#守印录2-14" class="headerlink" title="守印录2.14"></a>守印录2.14</h2><p>​       先对近期为学做个反思，昨天听了先生的讲解，发现我对于致良知的感受还是存在偏差，我以为我在致良知，实际上也执着于外物-私欲了，我把良知和私欲进行了区分，这一切都是我主观臆想，却觉察不到，还自以为我是在做致良知的功夫。越学越感觉自己无知。想要真正为学，唯有立志，唯有跟随先生系统为学。立志了，良知还会断吗？ 所以我下定决心报名心学班继续为学，我相信这是我此生最明智的决定。</p><p>​  然后刚才在知乎看到一个癌症患者的自诉，现在已经不再人世，让我久久不能平静，那撕心裂肺的痛苦，母亲望着孩子那深深崩裂的伤口，我真的隔着文字都能感受到悲痛。为什么世间会有病症，为什么要让这些善良的人经历如此磨难？她们所恳求的只是能够像正常人一样生活，甚至生来残疾也比受这磨难要好。</p><p>​不由联想到我这两天的放纵，在各种群里吹吹水，睡睡觉，发发呆。我是在浪费自己的生命啊。有多少人羡慕着这样的生活，不知生，焉知死。我想要我的生命生如夏花般绚烂，我想要活的精彩。我想立下志，可是还是心不诚。尝试着立下计划，尝试用过番茄钟专注学习，可是终究还是外物，如果没有一个恳切之志，终究会断。私欲一直都在，剪不断，理还乱。</p><p>​曾在晨课回答的心学难不难问题，那时我初学心学，意气风发，自信之至，不就致良知嘛，现在想想，致良知这三个字，就够我学一辈子的了。果然越学感觉自己越无知，为自己的洋洋自得而惭愧。</p><p>​      晚安 希望岁月静好 所有人幸福平安。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 内省 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物2.9</title>
      <link href="/2022/02/09/%E6%A0%BC%E7%89%A92-9/"/>
      <url>/2022/02/09/%E6%A0%BC%E7%89%A92-9/</url>
      
        <content type="html"><![CDATA[<p>1</p><p>又是一天，先来分析一下今天的成果，又有了哪些私欲，不错的地方是当内心有了要玩手机的念头，可以丢掉它。但今天又表现出另外两个问题，其一在于，学习学累了，休息的时候，这个时候拿着手机就很难停下来，要该怎么做呢，也许只能通过致良知，当拿起手机，就会不自觉的刷进视频，给自己定的，就看完这个视频就结束，可是事实往往不是这样，拿起来就停不下来了，这是一个很大得问题，明天需要注意，当休息时，我能不能发下此时的手机呢，走一走吗，活动活动。而不是给自己找个接口，其二，在于运动，又难坚持了，原因在于下雨，可是又因为内心私欲的隔绝，本可以在家就可以运动的，却也做不到。确实挺难的，那我这个志，是不是又算作废了呢。 </p><p>我现在内心比较在意的有几件事，只有不剩下十天不到就要开学了，我的英语学习却还差的老远，C语言刷题还没有找到方法，感觉还是那种看着就很累的感觉，这怎么才能打破，我总是想，我数学不好，可能这需要天赋吧。可是真是这样吗，我并没有在其中投入很多时间，我的英语三级，我的java学习，蓝桥杯，都断断续续，感觉不到很大的进步，一天的时间又到哪里去了，看不见，摸不着。害。完了现在脑子里又不知道写些啥了，啦啦啦。还是不不知道，似乎大脑空了，有了，今天在起床的时候，我告诉我立了志，既然醒了，就要马上起来，不要赖床，明天就先从这一件小事做起吧，希望可以成功。这还是很大的一个挑战，为什么内心总能给自己找到一个借口，为什么内心总会被遮蔽。我看王阳明心学的时候发现阳明先生用的很多剿灭盗贼的策略，都能在抗日战争，解放战争里看到影子，我推测，毛主席应该也是学习过王阳明心学的吧，还有，伟人喜欢写诗，这个诗是非物像化的，最真诚的表达，什么时候，我也可以达到这种写诗的境界呢。</p><p>还有呢，我许下了个心愿，我希望我可以笃实的致良知，不中断，未来是美好的，等着我去探索，其次我发现我现在最容易坚持的事情是什么，是读书，是练字，仿佛他已经成为了我生活的一部分。要是学习，技能上的也像这样一样就好了啊。 晚安 愿世界安好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心愿</title>
      <link href="/2022/02/09/%E5%BF%83%E6%84%BF/"/>
      <url>/2022/02/09/%E5%BF%83%E6%84%BF/</url>
      
        <content type="html"><![CDATA[<p>铁旦说心学晨思问题171:<br>2022壬寅年，你希望实现的最大愿望是什么呢？</p><p>回顾2021年，是我收获最大的一年了。说来也巧，来到铁旦说心学的契机，正是因为我为学过程中，羡慕古代先贤那种有先生，有师兄。为学遇到问题可以提问，听先生传道的氛围。看了传习录，也只觉一头雾水，走进不去。我的内心极度渴望这种为学氛围。很神奇的是，当时有个师兄加了我的qq,邀请我进入了铁旦说心学这个真诚为学向道的平台。在此也真诚的感谢这位师兄和铁旦说心学这个平台。有了先生，有了师兄。为学过程中，我也在不断感受致良知，知行合一所带给我的力量，下定决心去做致良知的功夫，尽管断断续续，可也总算看到了门。<br>2022年，我有很多愿望，可仔细想想， 立志，诚心致良知一条路足以。功夫间断，我自然会去反思为什么会间断，找到这个念头，私欲，比如当我在做一件事时，却突然想到另一件事，还会去做，就会打断此时的思维，浪费了时间。那如果我能等到下次念头出来，就革除掉，专心致志，不动心。如此，对待父母，我自然能真诚尽孝，对待学习，也自然能持之以恒，读书，练字，锻炼自然也能念念不忘，必有回响。于事事物物致良知，则必事事物物的愿望都能实现。<br>2022年，我最大的愿望就是不断诚心致良知，不退转，不间断。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物2-8</title>
      <link href="/2022/02/08/%E6%A0%BC%E7%89%A92-8/"/>
      <url>/2022/02/08/%E6%A0%BC%E7%89%A92-8/</url>
      
        <content type="html"><![CDATA[<p>1</p><p>转眼就到虎年了，这一年有什么收获呢，已经立下的志向，被自己的借口一次次遮蔽，曾经许下的诺言，却因为内心的私欲，一次次失信。这个良知真难啊，现在也不直到写些什么，先生说，致良知断断续续这是求学路上必须经历的，没有什么别的路径，唯有致良知一条路而已。最近和我姐姐谈到了我的父母，和她谈到了，这个世界最大的不公是认知的不公，并且总以为自己是对的，这个世界就如自己所臆想的那样，真的是这样吗，保持有求学谦虚的心，以及好奇心真的是一件很重要的事。我姐姐谈到了我母亲是一个她所处的时代很智慧的女性，也许并每没有很高的学历，很大的成就，可是却永远怀揣着善良，温柔。对身边人，我奶奶以前是那样的对她，一次次的哭泣。我都感同身受。她爱学习，且学习好，可惜处在那个时代。也许就是这样无法改变什么，不过也挺好，她依旧守着他的善良，晚上我们谈以前的事，我发现她什么事都记得，他能想到亲戚家一个残疾人的艰辛，不容易。能观察到我都发现不了的小事，真是给了我很大的震撼，这，不就是恻隐之心吗，在没学过心学的情况，她竟然说出，万事万物合一的话。她是我的妈妈，一个善良，智慧的女性。</p><p>再来谈谈今天的感悟，我用了两天时间，总共的学习时间只有9个小时，而总共将近有两倍的时间，那其中一倍的时间丢到哪去了呢。这次我刻意留意了一下，还是在手机上，我发现学习被打断的地方就在于，心中脑子里突然想到一件事，就要把所有事情停下来，去搞那件事，比如找资源，比如去淘宝买东西，看有没有，心中有想法我就要去搜索，这大大影响了我的时间，明天更需要注意，当产生这种想法的时候，就要革除，这是影响我思维的东西。</p><p>我在想，我到底什么时候能立志呢，为什么我这个志立不下来呢，为什么我致的良知会断断续续呢，那不如就从当下开始吧，我要立志，这句话话不对任何人说，只对我自己说。这个志，我立定了。</p><p>最近看到一个消息，很悲痛，我看到一个50岁的母亲失去了自己的孩子，她的孩子是B站的审核，因为熬夜加班猝死了，有些时候，卷和生命健康比起来，真的很重要吗，我内心产生了迟疑。我想先找到程序员的工作，青春可以有节制的努力，可以发光发亮。等到老了，我有很明确的心愿，我想像铁旦老师那样，成为先生，我也想讲心学，嘿嘿。想想就快乐，讲讲我的曾经。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 格物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/01/30/test/"/>
      <url>/2022/01/30/test/</url>
      
        <content type="html"><![CDATA[<p>dasdads</p><p>dsadasdddddddddddddddddddddddddddddsa</p>]]></content>
      
      
      
        <tags>
            
            <tag> hh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物1.20</title>
      <link href="/2022/01/19/%E6%A0%BC%E7%89%A91-19/"/>
      <url>/2022/01/19/%E6%A0%BC%E7%89%A91-19/</url>
      
        <content type="html"><![CDATA[<p>s</p><h1 id="1-19格物"><a href="#1-19格物" class="headerlink" title="1.19格物"></a>1.19格物</h1><p>现在的内心很难受，真的很难受，本来一提到测血压我就恐惧，今天突然就想测一下血压，结果一测，180，我的心停顿了几秒，这是真的吗，接着又测试了几次，结果都是一样。内心真的好难受啊，我第一次感受到了恐惧，感受到了死亡。</p><p>但是我是学心学的，我知道恐惧，害怕，担忧，改变不了什么。我的生活极其不规律，我熬夜，我不爱运动。就算没有这次血压，等我老了，他又会出现什么症状呢，绝症？还是癌症？。我不敢想象，我真的尽可能开导我记，我是学心学的，也许这就是一次机缘呢，这是告诉我，我不爱自己的身体，我不爱自己，又谈学什么心学呢，良久，但是内心终究是挺难受的，我不想我爸妈担心，不想看到这种情景。我还能怎么办，唯有积极的心态去战胜它，也许排除掉遗传基因，我对这爆表的血压，我也没有怨恨。这是我因得的，我的生活规律，决定了这个结果。我是该深刻反思一下了，究竟我在学什么，学这学那，却连根本的，我自己的身体。我都没有照顾好，我又有什么颜面，谈学心学。很多人因此而送命，我想战胜它，我把它当作是我人生的一个磨难，想死而生。借这次机会，我要感悟体会到老年面对的生老病死，可血压为什么不是130这种中和的呢，也许是老天看出来我的性格，不到绝境，我很难悔悟，那我可真的要好好感谢您了。当然是打心眼里感谢。如果不次这是，等我下一次意识到这个问题，也许我的声明已经没有了吧。</p><p>​再谈一谈，我之前体会不到，感恩之心，可从今天开始，我知道了，一个人能够看到明天的太阳照常升起，这是多么心愿啊，死可怕吗，可怕，可更可怕的是不知道如何面对死亡，或者是因为自己一生碌碌无为而懊悔，在死前，你是否让自己已经毫无遗憾，拥抱一些爸妈，这一天问一声好，问问大地，问问蓝天，哎，活着真好啊。那些在ICU重症监护室焦急等待的亲人，哪些为了缉毒而牺牲的警察，哪些为了维护祖国领土牺牲的战士，他才18岁，比我还小一岁啊。更不用提这次新馆疫情又带走了多少人的生命。岁月无常，不知道哪一天，你就再也看不到明天的太阳，只是希望每一天都不要留有遗憾。</p><p>这次血压的发现，促使我爱护我自己的身体，打心眼里爱护，每天 早晚，我要刷牙，晚上我要在9：50之前入睡，我不能再熬夜，我要我的每天都有运动，我要我的灵魂，肉体不再如一滩死水，我要给它新的生命，有什么大不了的呢，我难道还不能战胜者这小小高血压吗？他只是我人生中的一块炼金石，促使我走向圣贤，成为圣贤。 我爱我自己，我爱我的家人，如果能让我看每一天窗外射出来的光，看到我的家人，那我将心怀感激，无比虔诚！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 格物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物1.18</title>
      <link href="/2022/01/19/%E6%A0%BC%E7%89%A91-18/"/>
      <url>/2022/01/19/%E6%A0%BC%E7%89%A91-18/</url>
      
        <content type="html"><![CDATA[<h1 id="格物-1-18"><a href="#格物-1-18" class="headerlink" title="格物 1.18"></a>格物 1.18</h1><p>最近几天在按照规划执行的过程中，发现了几个很严重的问题，定力不足，分心，心容易骚乱。在感到疲惫的时候，会有歇一歇的念头，可在那念头闪现中，就不知觉的拿起了手机，拿起手机，以前主要是刷哔站，知乎。<br>     现在，最容易被影响的微信 和 QQ，一回起消息就是没完没了，可不禁反思，我在这聊天过程中收获到了什么呢 反而一次次打破我的行动规划。<br>    知行合一，真难啊，良知显现出来，致良知，真难啊。<br>回想今天的一天，计划打乱是从视频会议开始，早上是正常起床，晨读，练书法，可是到了学英语的时间段，有了视频会议，等到视频会议结束，这时候我拿起手机就停不下来了。错过了英语学习，知道下午两点，开始学习java课程，可是又犯困，休息的时候，又拿起了手机，回起了消息。学习效率极低，也就两节课。之后开始学C语言，做了两题。然后江边散了部，听先生讲心学，1.世间无鬼神，2.生命很脆弱，有能力应该尽可能帮助他人。</p><h2 id="明天应该怎么做？"><a href="#明天应该怎么做？" class="headerlink" title="明天应该怎么做？"></a>明天应该怎么做？</h2><p>上午严格按照计划执行，吃饭，1.10分吃完饭，不要莫手机，休息20分钟，起来学习java课程。学完之后按规划学习C语言。7-8点 自由安排学习感兴趣的，但是不能玩手机，8-9点 固定学心学，省察自己 写下反思。 剩余时间 学习java。 一有拿手机的念头，或者已经拿了。就告诉你，这个是私欲，这个念头得断，不然白规划了，知行要合一</p><p>思想进步：为什么致良知能够改变命运呢，因为人很难去改变固有认知，再加上固有的环境，你的脑回路就会把你带进这个方向，而致良知，是一种去私欲的过程，你的心存乎天理，自然会改变这个轨迹。</p><h2 id="师兄给的建议"><a href="#师兄给的建议" class="headerlink" title="师兄给的建议"></a>师兄给的建议</h2><p>A：师兄，在开始阶段，不要想着马上就能达到沉浸式投入学习，我这个毛病也很重，就是学个什么在一开始都想着游刃有余了。就踏踏实实的发现有分心的东西，如果是私欲，就去掉，可能去掉又会复发，就再去掉，重要的是保持功夫不断。共勉</p><p>你B：说的这个再正常不过了，你现在先别考虑念虑之外的事，只要有良知一念发动你察觉到了，就听其指引立马去做。做不到你就可以省察到底是什么原因让你知行不能合一了，一直改不掉的提出来大家一起讨论</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记内省 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pysquery</title>
      <link href="/2021/12/18/pysquery/"/>
      <url>/2021/12/18/pysquery/</url>
      
        <content type="html"><![CDATA[<p>n</p><h1 id="自从有了pyquery-我手里的xpath瞬间他就不香了"><a href="#自从有了pyquery-我手里的xpath瞬间他就不香了" class="headerlink" title="自从有了pyquery,我手里的xpath瞬间他就不香了"></a><strong>自从有了pyquery,我手里的xpath瞬间他就不香了</strong></h1>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxi5fffszwj30p00an453.jpg" >        </sapn>      <p>📢 大家好，我是<strong>小菜狗同学</strong>，一名大一的后端爱好者</p><p>📢 这篇文章将讲解爬虫中解析pysquery的用法</p><p>📢 非常感谢你的阅读，不对的地方欢迎指正 😘😘</p><p>📢 愿你忠于自己，热爱生活，生活中不仅要有技术，更有诗和远方。</p><p>📢本文内容参考   崔庆才&lt;网络爬虫开发实战第二版&gt;  </p><h2 id="1-如何安装biaoq"><a href="#1-如何安装biaoq" class="headerlink" title="1.如何安装biaoq"></a>1.如何安装biaoq</h2><pre><code class="python">pip install pyquery</code></pre><p>更加详细的安装可以参考<strong>崔庆才</strong>大佬，<a href="https://cuiqingcai.com/5186.html">https://cuiqingcai.com/5186.html</a></p><h2 id="2-为何选择使用pyquery"><a href="#2-为何选择使用pyquery" class="headerlink" title="2. 为何选择使用pyquery"></a>2. 为何选择使用pyquery</h2><p>我们知道目前主流的爬虫解析库：</p><ul><li>PyQuery</li><li>Beautifulsoup</li><li>Scrapy Selectors</li><li>正则表达式</li><li>xpath</li></ul><p>PyQuery和scrapy Selectors都是基于<strong>lxml</strong>模块，xlml和正则是基于C写的，只有Beautifulsoup是用纯python写的，所以解析速度，毫无疑问Beautifulsoup比其它解析满了五倍以上。而正则表达式比较复杂 容易出错，<strong>pyquery</strong>相较于xpath更简洁。<strong>你信不信当你看完，你会觉得你手里的这些他都不香了</strong></p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxi5klkpdkj310m0rg1cs.jpg" >        </sapn>      <h2 id="不信？下面来用一个实例感受一下"><a href="#不信？下面来用一个实例感受一下" class="headerlink" title="不信？下面来用一个实例感受一下"></a>不信？下面来用一个实例感受一下</h2><pre><code class="python"># 引入对象 取别名from pyquery import PyQuery as pqhtml = &#39;&#39;&#39;&lt;div&gt;    &lt;ul&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;# 初始化doc = pq(html)# 传入li节点 这样就可以选取所有li节点了print(doc(&#39;li&#39;))out:     &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</code></pre><h2 id="URL初始化"><a href="#URL初始化" class="headerlink" title="URL初始化"></a>URL初始化</h2><p>初始化的参数除了可以用字符串还可以使用url的方式传递，只需要指定Pyquery的<strong>对象参数为url</strong>即可</p><pre><code class="python">doc = pq(url=&#39;https://cuiqingcai.com&#39;)print(doc(&#39;title&#39;))out:/ &lt;title&gt;静觅丨崔庆才的个人站点&lt;\title&gt;</code></pre><p>这段代码是什么意思呢？首先Pyquery对象会去请求这个url，然后得到<strong>URL</strong>返回的内容初始化给pq类</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxi2z3nkmpj30pw0eqal0.jpg" >        </sapn>      <h2 id="文件初始化"><a href="#文件初始化" class="headerlink" title="文件初始化"></a>文件初始化</h2><pre><code class="python">doc = pq(filename=&#39;demo.html&#39;)print(doc(&#39;li&#39;))</code></pre><p>这样它会先读取本地的文件内容，然后将文件内容以字符串的形式传递给 pyquery 类来初始化。</p><h2 id="基本CSS选择器"><a href="#基本CSS选择器" class="headerlink" title="基本CSS选择器"></a>基本CSS选择器</h2><pre><code class="python">html = &#39;&#39;&#39;&lt;div id=&quot;container&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)print(doc(&#39;#container .list li&#39;))print(type(doc(&#39;#container .list li&#39;)))out:  &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</code></pre><p>这里我们初始化后，给doc传入了一个CSS选择器#container .list li <strong>意思是先选取id为container的节点，再选取其内部class为list的所有li节点</strong></p><p>下面，我们直接遍历这些节点，然后调用 text 方法，就可以获取节点的文本内容</p><pre><code class="python">doc = pq(html)lis = doc(&#39;#container .list li&#39;)for item in lis.items():    # 提取li节点的所有文本内容    print(item.text())</code></pre><h2 id="查找子节点"><a href="#查找子节点" class="headerlink" title="查找子节点"></a>查找子节点</h2><pre><code class="python">doc = pq(html)# 选取class为list的节点items = doc(&#39;.list&#39;)print(items)lis = items.find(&#39;li&#39;)print(type(lis))print(lis)</code></pre><p>find 的查找范围是节点的所有子孙节点,而如果我们只想查找子节点，那可以用 <strong>children</strong> 方法：</p><pre><code class="python">lis = items.children()print(type(lis))print(lis)</code></pre><p>如果要筛选所有<strong>子节点</strong>中符合条件的节点，比如想筛选出<strong>子节点中 class 为 active 的节点</strong>，可以向 children 方法传入 CSS 选择器 .active，代码如下：</p><pre><code class="python">doc = pq(html)items = doc(&#39;.list&#39;)a = items.children(&#39;.item-1&#39;)print(a)</code></pre><p>我们看到输出的结果已经做了筛选，留下了 class 为 .item-1 的节点。</p><h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><p> items.parent()方法 <strong>返回所有的 父辈节点</strong> 如果需要筛选 在其中传入CSS选择器</p><p>如果想返回祖先节点 <strong>ites.parents()即可</strong>*</p><h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><pre><code class="python">doc = pq(html)# 这里需要注意 这两种是截然不同的意义#在这个例子中我们首先选择 class 为 list 的节点，内部 class 为 item-0 和 active 的节点，也就是第 3 个 li 节点。很明显，它的兄弟节点有 4 个，那就是第 1、2、4、5 个 li 节点。li = doc(&#39;.list .item-0.active&#39;)# 这个写法表明首先取class为list的节点,内部class为item-0的节点,之后再选取其内部为active的节点li = doc(&#39;.list .item-0 .active&#39;)# 对兄弟节点再做筛选print(li.siblings(&#39;.active&#39;))print(li.siblings())</code></pre><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>pyquery 的选择结果既可能是多个节点，也可能是单个节点，类型都是 pyquery 类型，并没有返回列表。</p><p>对于单个节点来说，可以直接打印输出，也可以直接转成字符串</p><pre><code class="python">from pyquery import PyQuery as pqdoc = pq(html)li = doc(&#39;.item-0.active&#39;)print(li)print(str(li))</code></pre><p>对于有多个节点的结果，我们就需要用遍历来获取了。例如，如果要把每一个 li 节点进行遍历，需要调用 items 方法：</p><pre><code class="python">lis = doc(&#39;li&#39;).items()</code></pre><p>调用 items 方法后，会得到一个<strong>生成器</strong>，遍历一下，就可以逐个得到 <strong>li 节点对象了</strong>,每个对象非常灵活，可以继续使用如上的方法。</p><pre><code class="python">doc = pq(html)lis = doc(&quot;li&quot;).items()for i in lis:    print(i.text())</code></pre><h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><ul><li><p>获取属性</p></li><li><pre><code class="python">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    &lt;div id=&quot;container&quot;&gt;        &lt;ul class=&quot;list&quot;&gt;             &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;             &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;             &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt; &lt;/div&gt;&#39;&#39;&#39;doc = pq(html)a = doc(&#39;.item-0.active a&#39;)# print(a, type(a))print(a.attr(&#39;href&#39;))# link3.html</code></pre><p>当返回结果包含多个节点时，调用 attr 方法，只会得到第 1 个节点的属性。</p></li><li><p>获取文本</p><p>很简单</p><pre><code class="python">print(a.text())</code></pre><p>但如果你想要获取这个节点内部的 HTML 文本，就要用 html 方法了：</p><pre><code>print(a.html())</code></pre><p>text 方法不需要遍历就可以获取，它将所有节点取文本之后合并成一个字符串。</p><p>html 需要遍历获取 不然只能返回一个</p></li></ul><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove 方法就是移除</p><pre><code class="python">html = &#39;&#39;&#39;&lt;div class=&quot;wrap&quot;&gt;    Hello, World    &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt;&#39;&#39;&#39;from pyquery import PyQuery as pqdoc = pq(html)wrap = doc(&#39;.wrap&#39;)print(wrap.text())</code></pre><p>我们如果此时只想要Hello world怎么办，直接使用text()全部提取了</p><p>这时 remove 方法就可以派上用场了</p><pre><code class="python">wrap.remove(&#39;p&#39;)  # 选中p节点 remove移除即可</code></pre><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><pre><code class="python">li = doc(&#39;li:first-child&#39;)  # 第一个print(li)li = doc(&#39;li:last-child&#39;)  #最后一个print(li)li = doc(&#39;li:nth-child(2)&#39;)  # 第二个之后print(li)li = doc(&#39;li:gt(2)&#39;)  # 第三个之后print(li)li = doc(&#39;li:nth-child(2n)&#39;) # 偶数print(li)li = doc(&#39;li:contains(second)&#39;) #包含文本second的节点print(li)</code></pre><h2 id="THE-LAST"><a href="#THE-LAST" class="headerlink" title="THE LAST"></a>THE LAST</h2><p>关于 CSS 选择器的更多用法，可以参考：<a href="http://pyquery.readthedocs.io/en/latest/api.html%E3%80%82">http://pyquery.readthedocs.io/en/latest/api.html。</a></p><p>关于pyquery更多说明:<a href="http://pyquery.readthedocs.io/">http://pyquery.readthedocs.io</a></p><p>怎么样 是不是感觉手里的xpath瞬间他就不香了</p><p>求👍求💗</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxi5mjrptaj30j60j610a.jpg" >        </sapn>      ]]></content>
      
      
      
        <tags>
            
            <tag> pyquery 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSDN逆向</title>
      <link href="/2021/12/13/CSDN%E9%80%86%E5%90%91/"/>
      <url>/2021/12/13/CSDN%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="CSDN逆向分析思路"><a href="#CSDN逆向分析思路" class="headerlink" title="CSDN逆向分析思路"></a><strong>CSDN逆向分析思路</strong></h1><h2 id="1-先定义表结构"><a href="#1-先定义表结构" class="headerlink" title="1.先定义表结构"></a>1.先定义表结构</h2><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>char类型，要设置最大的长度</li><li>对于无法确定最大长度的 可以设置为text类型</li><li>设计表的时候，采集到的数据经量格式化</li><li>default值尽量设置,null&#x3D;true</li></ul><pre><code class="python">from peewee import *db = MySQLDatabase(&#39;spider&#39;,host=&#39;localhost&#39;,port=3306,user=&#39;root&#39;,password=&#39;1234&#39;)class BaseModel(Model):      class Meta:        database = db # This model uses the &quot;people.db&quot; database. 这张表对应哪个库class Topic(BaseModel):    title = CharField()    Content = TextField()    id = IntegerField()    author = CharField()    create_time = DateTimeField()    answer_nums = IntegerField(default=0)    chick_nums = IntegerField(default=0)    praised_nums = IntegerField(default=0)class Answer(BaseModel):    topic_id = IntegerField()    author = CharField()    create_time = DateTimeField()    Content = TextField()    praised_nums = IntegerField()class Author(BaseModel):    name = CharField()    id = IntegerField()    chick_nums = IntegerField()  # 访问数    original_nums = IntegerField(default=0) # 原创数    rate = IntegerField(default=-1) # 排名    answer_nums = IntegerField(default=0) # 评论数    praised_nums = IntegerField(default=0) # 获赞数        desc = TextField(null=True) # 描述    industry = CharField(null = True) # 关注的标签    followers = IntegerField(default=0) #粉丝数    if __name__ == &#39;__main__&#39;:    # 创建出框架     db.create_tables([Topic,Answer,Author])</code></pre><h2 id="2-简单确定反爬步骤"><a href="#2-简单确定反爬步骤" class="headerlink" title="2.简单确定反爬步骤"></a>2.简单确定反爬步骤</h2><ul><li><p>当我们拿到一个网站，首先可以尝试查看页面源代码 看是否包含</p></li><li><p>查看所有js文件 搜索关键词 如果有则证明写在js文件中</p></li><li><p>刚开始没有 极有可能在点击之后出现 在all里面可以找到data</p></li><li>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxcle203vyj31hc0u0azy.jpg" >        </sapn>      </li><li><p>分析url的构成 尝试写代码 发送请求获取响应</p><pre><code class="python">import requestsurl = &quot;https://bizapi.csdn.net/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=4&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 Safari/537.36&quot;&#125;resp = requests.get(url,headers=headers)print(resp.status_code)# 400 </code></pre></li><li><p>当加入了UA等常参数 仍然返回错误状态码时，采用暴力操作，将请求头全部加入 HTTP是无状态协议 也就是只要我能模仿出参数 浏览器就会通过</p></li><li><p>可是运行之后 我们发现返回403 表示没有权限</p></li><li><p>此时我们分析一下请求 不可能通过通用的一些协议来反爬 关键是找我们不熟悉的  以下四个我们不熟悉</p><pre><code>x-ca-key: 203899271x-ca-nonce: 036b20a8-ee16-4537-b475-ac9c7dbc7865x-ca-signature: QyWaJYtvndqtkQbBjvgniTMk69WaSD9r3sjPMcGZ5uc=x-ca-signature-headers: x-ca-key,x-ca-nonce</code></pre><p>一个判断方法是 参数是否固定 此时我们用无痕浏览重新打开网页 此时参数如下</p><pre><code>x-ca-key: 203899271x-ca-nonce: d00c7765-1d7b-4d5f-b5dc-4f348346b948x-ca-signature: eGrfMJvN+t9hftBqcbXBHoMSUpst+9ybt2KrRm4LJQg=x-ca-signature-headers: x-ca-key,x-ca-nonce</code></pre><p>我们发现 x-ca-nonce –暂时的 临时的只使用一次的 x-ca-signature –签名 这两个值不是固定的 也就是说这就是反爬的点</p></li><li><p>我们此时的任务是：分析那个<strong>临时参数</strong>怎么来的  <strong>签名咋来的</strong></p><p>(ps:签名是浏览器校验身份的一种密钥)</p></li><li><p>拿着x-ca-signature 去js文件一个一个找</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxcm4ihj3aj315u0oqdzn.jpg" >        </sapn>      </li><li><p>可是我们发现 是被压缩过的 此时打开 headers 找域名csdnim.cn  打开sources 找到这个域名的文件 打开</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxcmdpn56oj30sh0pr17k.jpg" >        </sapn>      <p>可以发现 是通过p函数的 </p></li><li><p>在想进入的函数打个断点</p></li><li><p>在界面随便点进去一个 发现进入调试模式 此时进入函数内部 step into</p></li><li><p>如果此函数实现 没有其它函数 可以直接使用python模拟生成</p></li></ul><pre><code class="python">import execjsnonce_func =execjs.compile(&quot;&quot;&quot;p = function(e) &#123;            var t = e || null;            return null == t &amp;&amp; (t = &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, (function(e) &#123;                var t = 16 * Math.random() | 0;                return (&quot;x&quot; === e ? t : 3 &amp; t | 8).toString(16)            &#125;            ))),            t        &#125;&quot;&quot;&quot;)print(nonce_func.call(&quot;p&quot;, ))# 2840f71f-8c29-4df1-ab90-8d519ca25fc2</code></pre><ul><li><p>通过调试 看看他的算法实现</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gxcnzir2hfj30xz0n7qgf.jpg" >        </sapn>      </li></ul><pre><code>i:bK9jk5dBEtjauy6gXL7vZCPJ1fOy076H 固定的&quot;GETapplication/json, text/plain, */*x-ca-key:203899271x-ca-nonce:21b07f14-581f-49e3-b1e0-30b3d7b5e028/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=1&quot;</code></pre><ul><li><p>传递两个参数就可得到</p></li><li><p>接着就是用python去模拟这些算法 得到返回值，然后赋值给headers中的内容</p></li><li><pre><code class="python">import requestsimport execjsfrom base64 import b64decode, b64encodeimport hmacimport hashlib# 一个密钥nonce_func = execjs.compile(&quot;&quot;&quot; p = function(e) &#123;    var t = e || null;    return null == t &amp;&amp; (t = &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, (function(e) &#123;        var t = 16 * Math.random() | 0;        return (&quot;x&quot; === e ? t : 3 &amp; t | 8).toString(16)    &#125;    ))),    t&#125;&quot;&quot;&quot;)def gen_sign(nonce_str,url):    data = &quot;GET\n&quot;    data +=&quot;application/json, text/plain,*/*\n&quot;    data += &quot;\n\n\n&quot;    # data += &quot;\n&quot;    # data += &quot;\n&quot;    data += &quot;x-ca-key:203899271\n&quot;    data += &quot;x-ca-nonce:&#123;&#125;\n&quot;.format(nonce_str)     data += url    print(data)    # &quot;/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=3&quot;    # data = &#39;GET\napplication/json, text/plain,*/*\n\n\n\nx-ca-key:203899271\nx-ca-nonce&#39; \    #        f&#39;:&#123;nonce_str&#125;\n/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=3&#39;    app_secret_key =  &quot;bK9jk5dBEtjauy6gXL7vZCPJ1fOy076H&quot;    data = data.encode(&quot;utf-8&quot;)    sign = b64encode(hmac.new(app_secret_key.encode(&#39;utf-8&#39;),data,digestmod=hashlib.sha256).digest()).decode()    return sign    template =&quot;&quot;&quot;GETapplication/json, text/plain,*/*x-ca-key:203899271x-ca-nonce:49d2d8b8-f978-4291-8cdc-4d6d4ef2b732/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=5&quot;&quot;&quot;# url = &quot;/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=3&quot;nonce_str = nonce_func.call(&quot;p&quot;,)# print(&quot;随机值&quot;+nonce_str)headers = &#123;   &quot;accept&quot;: &quot;application/json, text/plain,*/*&quot;,&quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;,&quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9&quot;,&quot;origin&quot;:&quot;https://bbs.csdn.net&quot;,&quot;referer&quot;:&quot;https://bbs.csdn.net/forums/qing_gee?category=4&quot;,&quot;sec-ch-ua&quot;: &quot;&quot;&quot;Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;96&quot;, &quot;Google Chrome&quot;;v=&quot;96&quot; &quot;&quot;&quot;,&quot;sec-ch-ua-mobile&quot;:&quot;?0&quot;,&quot;sec-ch-ua-platform&quot;: &quot;Windows&quot;, &quot;sec-fetch-dest&quot;: &quot;empty&quot;,&quot;sec-fetch-mode&quot;: &quot;cors&quot;,&quot;sec-fetch-site&quot;: &quot;same-site&quot;,&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 Safari/537.36&quot;,&quot;x-ca-key&quot;: &quot;203899271&quot;,&quot;x-ca-nonce&quot;: nonce_str, # nonce 随机的 只使用一次# 签名&quot;x-ca-signature&quot;: gen_sign(nonce_str,&quot;/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=3&quot;), # 签名 算法+密钥&quot;x-ca-signature-headers&quot;: &quot;x-ca-key,x-ca-nonce&quot;, # 固定&#125;# print(&quot;签名&quot;+gen_sign(nonce_str,&#39;/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=3&#39;))url = &#39;https://bizapi.csdn.net/community-cloud/v1/homepage/community/by/tag?deviceType=PC&amp;tagId=3&#39;resp = requests.get(url,headers=headers)print(resp.status_code)print(resp.text)</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js 爬虫逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socke编程</title>
      <link href="/2021/12/10/socke%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/12/10/socke%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>1</p><h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a><strong>Socket编程</strong></h1><ol><li><p>encode：编码</p></li><li><p>decode：解码</p></li><li><h2 id="Python字节到字符串-作为概念有必要理解"><a href="#Python字节到字符串-作为概念有必要理解" class="headerlink" title="Python字节到字符串 (作为概念有必要理解)"></a>Python字节到字符串 <strong>(作为概念有必要理解)</strong></h2><p>We can convert bytes to String using bytes class decode() instance method.</p><p>我们可以使用<strong>bytes类的decode（）实例方法将字节转换为String。</strong></p><p>Let’s look at examples of converting a string to bytes and then bytes to string in a python program.</p><p>让我们看一下在python程序中将字符串转换为字节然后将字节转换为字符串的示例。</p><pre><code class="python">【】s = &#39;abc&#39;# string to bytes using bytes()b = bytes(s, encoding=&#39;utf-8&#39;)print(type(b))print(b)# bytes to string using decode()s = b.decode()print(&#39;Original String =&#39;, s)s = &#39;xyz&#39;# string to bytes using encode()b = s.encode(encoding=&#39;utf-8&#39;)print(b)s = b.decode()print(&#39;Original String =&#39;, s)</code></pre></li></ol><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p>当应用程序和TCP进行交互时，里面会有一个接口层，也就是Socket.本身不是一个协议，但是可以让他和TCP直接打交道。</p><p>        <span class="lazyload-img-span">        <img              data-src="/image-20211210105536253.png" >        </sapn>      </p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>        <span class="lazyload-img-span">        <img              data-src="/image-20211210105722042.png" >        </sapn>      </p><h3 id="客户端：新建套接字-socket-—–-gt-连接远程服务器-connect-—–-gt-发送-x2F-接收数据-send-x2F-recv-—–-gt-关闭连接-close"><a href="#客户端：新建套接字-socket-—–-gt-连接远程服务器-connect-—–-gt-发送-x2F-接收数据-send-x2F-recv-—–-gt-关闭连接-close" class="headerlink" title="客户端：新建套接字 socket() —– &gt; 连接远程服务器 connect() —– &gt;  发送&#x2F;接收数据 send&#x2F;recv —– &gt;  关闭连接 close()"></a>客户端：新建套接字 <strong>socket()</strong> —– &gt; 连接远程服务器 <strong>connect()</strong> —– &gt;  发送&#x2F;接收数据 send&#x2F;recv —– &gt;  关闭连接 <strong>close()</strong></h3><h3 id="服务端：新建套接字-socket-——-gt-绑定端口-bind-——-gt-监听端口-listen-——-gt-阻塞等待客户连接-accept-——-gt-recv-x2F-send-接收-x2F-发送数据-——-gt-close-关闭-连接"><a href="#服务端：新建套接字-socket-——-gt-绑定端口-bind-——-gt-监听端口-listen-——-gt-阻塞等待客户连接-accept-——-gt-recv-x2F-send-接收-x2F-发送数据-——-gt-close-关闭-连接" class="headerlink" title="服务端：新建套接字 socket() ——&gt;绑定端口 bind() ——-&gt; 监听端口 listen()  ——&gt; 阻塞等待客户连接 accept() ——&gt; recv&#x2F;send 接收&#x2F;发送数据 ——- &gt; close  关闭  连接"></a><strong>服务端：</strong>新建套接字 socket() ——&gt;绑定端口 bind() ——-&gt; 监听端口 listen()  ——&gt; 阻塞等待客户连接 accept() ——&gt; recv&#x2F;send 接收&#x2F;发送数据 ——- &gt; close  关闭  连接</h3>]]></content>
      
      
      
        <tags>
            
            <tag> socket编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阶乘求和</title>
      <link href="/2021/11/27/%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C/"/>
      <url>/2021/11/27/%E9%98%B6%E4%B9%98%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="阶乘求和"><a href="#阶乘求和" class="headerlink" title="阶乘求和"></a>阶乘求和</h1><p><strong>题目描述</strong></p><p>求Sn&#x3D;1!+2!+3!+4!+5!+…+n!之值，其中n是一个数字(n不超过20)。</p><p><strong>输入</strong></p><p>n</p><p><strong>输出</strong></p><p>Sn的值</p><p><strong>样例输入复制</strong></p><pre><code>5</code></pre><p><strong>样例输出复制</strong></p><pre><code>153</code></pre><p><strong>思路分析：</strong></p><p>题目要求需要求阶乘的和，我们的初步想法是定义一个<strong>求阶乘的递归函数</strong>，再定义一个<strong>主函数</strong>，通过<strong>遍历</strong>，1-n将数字传入fac中，之后 加到sum里。</p><p><strong>注意事项：</strong></p><p>1.采取自定函数求阶乘。用递归法。需注意递归法的尽头。（在本题中，fac函数的if语句作递归法的尽头，不可省略。）</p><p>2.要注意最后结果的数值范围，避免溢出发生错误。</p><p>阶乘很容出现<strong>数值溢出</strong>的问题，所以我们要<strong>扩大数值的存储范围</strong></p><pre><code>类型名称      字节数  取值范围signed` `char`      `1    -128～+127short` `int`       `2    -32768～+32767int`          `4    -2147483648～+2147483647long` `int`       `4    -2147483648～+2141483647long` `long` `int`     `8    -9223372036854775808～+9223372036854775807</code></pre><pre><code>//long int   的简写是   long     占位符是：%ld   //long long int的简写是   long long   占位符是：%lld</code></pre><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><pre><code class="c++">#include &lt;iostream&gt;using namespace std;//设计的递归函数 返回阶乘值long int fac(int n)&#123;        //long int 避免溢出    if(n==0)&#123;        //递归法到尽头 返回1        return 1;    &#125;    return  (fac(n-1)*n);&#125;//主函数int main()&#123;    //思路:先设计一个函数求出每个阶乘    int n;    long int s=0;    cin &gt;&gt; n;    for(int i=1; i&lt;=n; i++)&#123;        s += fac(i);    &#125;    cout &lt;&lt; s &lt;&lt;endl;    return 0;&#125;// 时间复杂度O(N)//空间耗费多 能不用递归就不用递归</code></pre><p><strong>思路二（首选）：</strong></p><p>我们看第第二次循环的时候也就是2!,此时等于前一个数的阶乘*当前数</p><p> 第三次循环的时候，3!&#x3D; 2! * 3</p><p> 第四次循环，     4!&#x3D;3! * 4</p><p> 1*1</p><p>1*2</p><p>1  * 2 *  3</p><p>我们可以退出 </p><p>t *&#x3D;i;</p><p>s +&#x3D;t</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code class="c++">#include &lt;stdio.h&gt;int main()&#123;    int n;    long long int sum = 0, t = 1;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        t *= i;        sum += t;    &#125;    printf(&quot;%lld&quot;, sum);&#125;</code></pre><p>推荐这个算法，时间复杂度O(n)，但是空间占用小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法解题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心得</title>
      <link href="/2021/11/24/%E5%BF%83%E5%BE%97/"/>
      <url>/2021/11/24/%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>1</p><h1 id="读书心得"><a href="#读书心得" class="headerlink" title="读书心得"></a>读书心得</h1><p> 1.推荐书《硅谷之火》<br>    2.上大学重要的不是学习知识，而是学会如何学习知识，重要的主动学习的方法和技能。<br>    3.大学生不适合刚开始就直接创业，因为缺乏行业经验，就算勉强做成，对于长久发展来说，也不算优势。ps：积累编程经验，互联网知识，多实践。<br>    4.要有胆量去想，想好在做，不要盲目（和传习录 知行合一有点矛盾 待考证）<br>    5.要有梦想<br>    6.无需被专业不对所影响，那样就成为了被动学习，当知道了如何学习，一切just soso</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数和最小公倍数</title>
      <link href="/2021/11/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2021/11/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>2</p><h1 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h1><p>输入两个正整数m和n，求其最大公约数和最小公倍数。</p><p><strong>输入</strong></p><p>两个整数</p><p><strong>输出</strong></p><p>最大公约数，最小公倍数</p><p><strong>样例输入复制</strong></p><pre><code>5 7</code></pre><p><strong>样例输出复制</strong></p><pre><code>1 35</code></pre><p><strong>思路</strong>:</p><p>首先我们需要了解，最小公因数和最小公倍数的相关性质</p><p>两数的乘积 &#x2F; 最大公因数 &#x3D; 最小公倍数</p><p><strong>所以要求最大公因数和最小公倍数，只需求出其一就可直接利用性质，完成题目。</strong></p><p>辗转相除法是古希腊求两个正整数的最大公约数的，也叫欧几里德算法，其方法是用较大的数除以较小的数，上面较小的除数和得出的余数构成新的一对数，继续做上面的除法，直到出现能够整除的两个数，其中较小的数（即除数）就是最大公约数。以求288和123的最大公约数为例，操作如下：</p><p>288 % 123 &#x3D;&#x3D; 42</p><p>123 % 42 &#x3D;&#x3D; 39</p><p>42 % 39 &#x3D;&#x3D;  3</p><p>39 % 3 &#x3D;&#x3D; 0</p><p>此时3 就是288和 133的最大公约数</p><p>结构大致如此 , num1 num2 使用大数取模小数</p><p>t &#x3D; m% n</p><p>m  &#x3D; n</p><p>n &#x3D; t</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code class="java">#include &lt;iostream&gt;using namespace std;int main()&#123;    int n,m,num1,num2;    //输入两个数    int t = 1;    cin &gt;&gt; num1 &gt;&gt; num2;    m = num1;    n = num2;    if(m&gt;n)&#123;        //进入循环 辗转相除        while(t != 1)&#123;            t = m % n;            m = n;            n = t;        &#125;        //求最小公倍数        int b = (num1*num2) / m;         cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt;endl;    &#125;else if(m &lt; n)&#123;        while(t!=0)&#123;            t = n % m;            n = m;            m = t;        &#125;        int b = (num1*num2)/n;        cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; b;    &#125;else if(m==n)&#123;        //直接输出最小公倍数 公约数都相同        cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt;endl;    &#125;        return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法解题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字处理与判断</title>
      <link href="/2021/11/13/%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%A4%E6%96%AD/"/>
      <url>/2021/11/13/%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>2</p><h1 id="数字的处理与判断"><a href="#数字的处理与判断" class="headerlink" title="数字的处理与判断"></a><strong>数字的处理与判断</strong></h1><p><strong>题目描述</strong></p><p>给出一个不多于5位的整数，要求 1、求出它是几位数 2、分别输出每一位数字 3、按逆序输出各位数字，例如原数为321,应输出123</p><p><strong>输入</strong></p><p>一个不大于5位的数字</p><p><strong>输出</strong></p><p>三行 第一行 位数 第二行 用空格分开的每个数字，注意最后一个数字后没有空格 第三行 按逆序输出这个数</p><p>样例输入复制</p><pre><code>12345</code></pre><p>样例输出复制</p><pre><code>51 2 3 4 554321</code></pre><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><strong>分析</strong>：这题如果按照常规思路比较麻烦，1.确定循环位数 2.循环正序输出 3. 循环逆序输出 所以我们采用字符串的</p><p><strong>解题思路</strong>：</p><p>将输入的数字按照字符串来存储，用strlen()得到字符串的长度 ，那么第一问就解决了</p><p>然后将字符串从左到右输出 再出右往作输出 即可</p><pre><code class="java">#include&lt;iostream&gt;#include &lt;cstring&gt;//注意事项：////题目说数字位数不超过5，所以定义字符数组长度应不小于6////因为字符串结尾还有结尾符 &#39;\0&#39; 占一位using namespace std;int main()&#123;    char str[10];//定义字符串长度为10    cin &gt;&gt; str;    int len = strlen(str);//求出字符串的长度    cout &lt;&lt; len &lt;&lt; endl;    //从左到右遍历输出    for(int i = 0; i &lt; len; i++)&#123;        //对于格式的处理        if(i==0)&#123;            cout &lt;&lt; str[i];        &#125;else&#123;                cout &lt;&lt; &quot; &quot; &lt;&lt; str[i];        &#125;    &#125;    cout &lt;&lt; endl;    //逆序输出 中间没有空格    for(int i = len-1 ; i &gt;= 0; i--)&#123;        cout &lt;&lt; str[i];    &#125;    cout &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格物1</title>
      <link href="/2021/11/09/%E6%A0%BC%E7%89%A91/"/>
      <url>/2021/11/09/%E6%A0%BC%E7%89%A91/</url>
      
        <content type="html"><![CDATA[<p>A</p><h1 id="格物心得——记2021-11-9"><a href="#格物心得——记2021-11-9" class="headerlink" title="格物心得——记2021.11.9"></a><strong>格物心得</strong>——记2021.11.9</h1><p>这次我来格一件事，我想这件事让我意识到我很多不到位的地方。事情经过大概是我在群里开玩笑说专业不好的言论被某个人截图发给了老师，传到了专业群那里，然后我就被老师叫去谈话了。我就讲一下我的心路经过吧，起初那我操他妈的肯定很气，我特么发东西管他屁事，我还不认识他。做小人就那么有意思，我也不知道都大学了还有时间做这种屁事，而且是两次聊天记录被传。</p><p>当然我现在写下这个的时候内心已经很平静了，既然我不能去改变别人，那我何必被这种小事所影响心境，而我能被影响只能说心境未到，先客观分析，老师知道了这件事又怎样，第一，我以为的老师的看法，可能和老师想的不一样呢，第二，我为什么要在意别人的看发，且不说本件事情本来就很滑稽，我说我没开学前劝退了一个同学去别的专业，这件事且不论对错，给出一个更适合自己发展的建议。其次，当时专业早填报完了，我如何去劝退他？那如果我说的对，我应该庆幸别人把我说的话发扬光大，如果我说的不对，那也许就是在老师那里丢一次人，又有什么关系。</p><p><strong>心得感悟</strong>：谈完了客观事实，我来讲讲我该如何安顿我的这颗无限心，有烦恼当然是正常的，而且未必不是我成长中的养分。这也许就是我一个修心的契机，我为何要去想他人的恶，我越想他只会让我自己越来越迷失。让情绪影响我的心。</p><p>既然想不了别人，那就内省自己。我做错了吗？，那我认为，自然而然的吐槽是没有问题的，但是呢，当我深思了半天之后，突然发现了我现在的处境，虽然已没了往年的自卑，却朝着另一种方向发展，锋芒毕露.</p><pre><code class="text">纪渻子为王养斗鸡。十日而问：“鸡已乎？”曰：“未也，方虚骄而恃气。”十日又问，曰：“未也，犹应向景。”十日又问，曰：“未也，犹疾视而盛气。”十日又问，曰：“几矣。鸡虽有鸣者，已无变矣，望之似木鸡矣，其德全矣，异鸡无敢应者，反走矣。” </code></pre><p><strong>纪渻子为王养斗鸡。十日而问：“鸡已乎？”曰：“未也，方虚骄而恃气。”</strong></p><p>我现在也许就是这个状态，过于张扬，能力却不足，只是凭借一股血气而骄傲自负，虽有上进心，却不懂内敛，内省。经过了很多事，我发现，这就是我目前的境地。</p><p>所以你问我，现在还气么，我的回答是：<strong>JUST SOSO</strong>。反而，我还要感谢他，经过这件事，让我内省自己，找准我现在的状态，从而找到我下一个应该去往的境界。😋👍</p><p><strong>无善无恶心之体</strong></p><p><strong>有善有恶意为动</strong></p><p><strong>知善知恶是良知</strong>          -处理一件事的时候，一定要先放下对一个人的执念，通过良知对于这件事进行判断</p><p><strong>为善去恶是格物</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 格物致知心得集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2021/11/07/%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/07/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#线性表</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><strong>线性表</strong></h1><h2 id="定义：什么是线性表"><a href="#定义：什么是线性表" class="headerlink" title="定义：什么是线性表"></a>定义：什么是线性表</h2><p>线性表是N各数据元素的有限序列，最常用的是链式表达，通常也叫做线性链表或者链表。</p><p>而在其中存储的数据元素，叫做<strong>结点</strong>，一个节点存储的就是一条数据记录。</p><p>每个节点的的结构包括两个部分。</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gw6g1lclr8j307p02ojre.jpg" >        </sapn>      <p><strong>PART1:具体的数据值</strong></p><p><strong>PART2：指向下一个节点的指针</strong>、</p><p>在链表的最前面，通常会有个头指针用来指向第一个节点。  （ps：头指针一般是固定了，如果需要使用往往我们需要开辟临时变量）</p><p>在链表的最后买南，由于在它之后没有下一个节点，因此它的指针是一个空指针。通常记为null</p><h2 id="什么是单向链表："><a href="#什么是单向链表：" class="headerlink" title="什么是单向链表："></a>什么是单向链表：</h2><p>例如：你需要处理的数据集是10个同学的考试得分。</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gw6g97qragj30x801m0tu.jpg" >        </sapn>      <p>这个链表只能通过上一个结点的指针找到下一个节点，反过来行不通。这种就被成为单向链表。</p><p><strong>改造1</strong>：将最后一个元素的指针指向第一个元素，就得到了<strong>循环链表</strong></p><p>        <span class="lazyload-img-span">        <img              data-src="/Ciqc1F7OU2qAaiymAAA-hJj3ddw282.png" >        </sapn>      </p><p><strong>改造2</strong>：改造结点结构，除了有指向下一个节点，再增加一个指向上一个节点的指针，这样就得到了<strong>双向链表</strong></p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gw6gce4mjmj30x801mq48.jpg" >        </sapn>      <p><strong>改造3</strong>：双向链表和循环链表融合，得到<strong>双向循环链表</strong></p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gw6gf4jcbij30my04a3zh.jpg" >        </sapn>      <h2 id="围绕增删查处理"><a href="#围绕增删查处理" class="headerlink" title="围绕增删查处理"></a>围绕增删查处理</h2><ol><li><h3 id="增加操作"><a href="#增加操作" class="headerlink" title="增加操作"></a>增加操作</h3><p>如下有一个链表，它存储了 10 个同学的考试成绩。现在发现这样的问题，在这个链表中，有一个同学的成绩忘了被存储进去。假设我们要把这个成绩在红色的结点之后插入，那么该如何进行呢？</p>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gw6ghtvj0bj30tq05l75p.jpg" >        </sapn>      <p>思路：待插入结点的指针指向原指针的目标，把原来的指针指向待插入的结点，就可以了。</p><pre><code class="java">s.next = p.next;p.next = s;</code></pre></li><li><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>接下来我们看一下删除操作。还是这个存储了同学们考试成绩的链表，假设里面有一个成绩的样本是被误操作放进来的，我们需要把这个样本删除。</p><p>        <span class="lazyload-img-span">        <img              data-src="/CgqCHl8ESbaAJi2xAAA-XJSjXw4037.png" >        </sapn>      </p><p>思路：太简单了，不解释 ，如果待删除的结点为b，只需要把指向b的指针指向c即可</p><pre><code class="java">p.next = p.next.next</code></pre></li><li><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a><strong>查找操作</strong></h3><p><strong>第一种情况是按照位置序号来查找。</strong></p><p>假设一个链表中，按照学号存储了 10 个同学的考试成绩。现在要查找出学号等于 5 的同学，他的考试成绩是多少，该怎么办呢？</p><p>唯一的办法就是一个一个地遍历去查找。也就是，从头开始，先找到学号为 1 的同学，再经过他跳转到学号为 2 的同学。直到经过多次跳转，找到了学号为 5 的同学，才能取出这个同学的成绩</p><p><strong>第二种情况是按照具体的成绩来查找。</strong></p><p>同样，假设在一个链表中，存储了 10 个同学的考试成绩。现在要查找出是否有人得分为 95 分。链表的价值在于用指针按照顺序连接了数据结点，但对于每个结点的数值则没有任何整合。当需要按照数值的条件进行查找时，除了按照先后顺序进行遍历，别无他法。</p><p>因此，解决方案是，判断第一个结点的值是否等于 95：</p><ul><li><p>如果是，则返回有人得分为 95 分；</p></li><li><p>如果不是，则需要通过指针去判断下一个结点的值是否等于 95。以此类推，直到把所有结点都访问完。</p></li></ul></li><li><p><strong>情况总结</strong></p><p>不难发现，链表在，<strong>新增和删除数据</strong>都比较容易，不需要大幅改动，可以在O（1）时间复杂度内完成，但是对于<strong>查找</strong>，不管是按照位置，还是按条件，都需要对全部数据进行遍历，这显然就是<strong>O（N）</strong>的复杂度。更不用说其复杂的代码量。</p><p>虽然链表在新增和删除数据上有优势，但仔细思考就会发现，这个优势并不实用。这主要是因为，在新增数据时，通常会伴随一个查找的动作。例如，在第五个结点后，新增一个新的数据结点，那么执行的操作就包含两个步骤：</p><p>第一步，<strong>查找</strong>第五个结点；</p><p>第二步，再<strong>新增一个数据结点</strong>。整体的复杂度就是 <strong>O(n) + O(1)。</strong></p></li></ol><p>线性表真正的价值在于，它对数据的存储方式是<strong>按照顺序的存储</strong>。如果数据的元素<strong>个数不确定</strong>，且需要经<strong>常进行数据的新增和删除时</strong>，那么<strong>链表</strong>会比较合适。如果数据元素<strong>大小确定</strong>，<strong>删除插入的操作</strong>并不多，那么数组可能更适合些。</p><h2 id="线性表案例"><a href="#线性表案例" class="headerlink" title="线性表案例"></a>线性表案例</h2><p><strong>例 1，链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</strong></p><p>分析：</p><ul><li><p>如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。</p></li><li><p>但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。具体如下图所示：</p><pre><code class="java">while(curr)&#123;    next = curr.next;    curr.next = prev；    prev = curr;    curr = next;&#125;</code></pre></li></ul><p><strong>例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</strong></p><p>这个问题也是利用了链表的长度无法直接获取的不足做文章，解决办法如下：</p><p>一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</p><p>除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</p><pre><code class="java">while(fast &amp;&amp; fast.next &amp;&amp; fast.next.next)&#123;    fast = fast.next.next;    slow = slow.next;&#125;</code></pre><h1 id="THE-LAST"><a href="#THE-LAST" class="headerlink" title="THE LAST"></a>THE LAST</h1><p>经过我们的分析，链表在<strong>增、删</strong>方面比较容易实现，可以在 <strong>O(1)</strong> 的时间复杂度内完成。但对于<strong>查找</strong>，不管是按照位置的查找还是按照数值条件的查找，都需要对全部数据进行<strong>遍历</strong>。</p><p>线性表的价值在于，它对数据的存储方式是<strong>按照顺序的存储</strong>。当数据的元素<strong>个数不确定</strong>，且需要经常进行<strong>数据的新增和删除时</strong>，那么链表会比较合适。链表的<strong>翻转</strong>、<strong>快慢指针</strong>的方法，是必须掌握的内容。(ps:现有水平理解不了)</p><p><strong>简单的代码实操</strong></p><pre><code class="java">package com.algorithm;public class Linked &#123;    public static void main(String[] args) &#123;        SingleLinkedListDemo singleLinkedListDemo = new SingleLinkedListDemo();        //添加几个节点        HeroNode node1 = new HeroNode(1, &quot;桥本有菜&quot;);        HeroNode node2 = new HeroNode(2, &quot;波多野结衣&quot;);        HeroNode node3 = new HeroNode(3, &quot;三上悠亚&quot;);        HeroNode node4 = new HeroNode(4, &quot;吕布&quot;);        HeroNode node5 = new HeroNode(5, &quot;凋残&quot;);        //添加节点        singleLinkedListDemo.addHeroNode(node1);        singleLinkedListDemo.addHeroNode(node2);        singleLinkedListDemo.addHeroNode(node3);        singleLinkedListDemo.addHeroNode(node4);        singleLinkedListDemo.addHeroNode(node5);        //显示节点        singleLinkedListDemo.showList(singleLinkedListDemo.getHead());        System.out.println(&quot;我是分界线--------------&quot;);        //修改凋残为西施        singleLinkedListDemo.updateLinked(new HeroNode(5,&quot;西施&quot;));        singleLinkedListDemo.showList(singleLinkedListDemo.getHead());    &#125;&#125;class SingleLinkedListDemo&#123;    //定义一个头节点//    private HeroNode head = new HeroNode(0,&quot;&quot;);    //先初始化一个头结点，头结点不能动，头结点不能变化，方便找到链表的头    private HeroNode head = new HeroNode(0,&quot;&quot;);    //我头节点是用来方便查找    //有个方法获取头节点    public HeroNode getHead()&#123;        return head;  //返回头节点    &#125;    //添加节点    public void addHeroNode(HeroNode heroNode)&#123;        //因为head节点是不能动的 因此我们需要有一个辅助节点temp 来遍历        HeroNode temp = head;        while (true)&#123;            //添加数据是从链表最后添加 如何确定最后的位置，只能节点.next，这样遍历下去，直到值位Null            if(temp.next == null)&#123; //此时指向最后一个节点                break;            &#125;            temp = temp.next;        &#125;        temp.next = heroNode;    &#125;    //查看链表    public void showList(HeroNode head) &#123;//传入头节点//        判断列表是否为空        if(head.next == null)&#123;            System.out.println(&quot;列表为空&quot;);        &#125;        //因为头节点是不能动的 所以需要辅助遍历来遍历        HeroNode temp = head.next;        while (true)&#123;            if(temp==null)&#123;                break;            &#125;            System.out.println(temp);            //打印完之后temp后移            temp = temp.next;            &#125;        &#125;        //修改链表节点//    1.刘备 ————&gt; 2.Zhangfei ——————&gt;3关羽//    temp.id =    public void updateLinked(HeroNode heroNode)&#123;        //判断列表是否为空        if(head.next==null)&#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        //定义一个辅助节点        HeroNode temp = head.next;        boolean flag = false;        while (true)&#123;            //是否找到对应节点            if (temp.id==heroNode.id)&#123;                flag = true;                break;            &#125;            if(temp.next==null)&#123;                break; //防止空指针异常            &#125;            temp = temp.next;//temp后移        &#125;        if(flag)&#123;            temp.name = heroNode.name;        &#125;else&#123;            System.out.println(&quot;没有找到id为&quot;+heroNode.id);        &#125;    &#125;    //删除节点    public void delLinkedList(int id)&#123;        HeroNode temp = head; //辅助        boolean flag = false;        //找到待删除节点的前一个节点        while (true)&#123;            if(temp.next==null)&#123;                break; //已经到最后需要退出循环            &#125;            if(temp.next.id ==id)&#123;                flag = true;                break;            &#125;            temp = temp.next;            if(flag)&#123;                //中间刚好空开一个.next                temp.next = temp.next.next;            &#125;else&#123;                System.out.println(&quot;没有找到id为&quot;+id);            &#125;        &#125;    &#125;&#125;//定义一个节点类 里面放数据class HeroNode&#123;    public int id;    public String name;    public HeroNode next; //指针 用来指向下一个节点    public HeroNode(int id, String name) &#123;        this.id = id;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;,&quot;;    &#125;&#125;/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹/////////////////艹 坚持一会 不搞完不睡觉 mdmdmdmmdmdmmdmmdmdmmdmdmdmm操操操操操操操操操操操操操哦啊从操操操艹</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心得</title>
      <link href="/2021/10/28/day1/"/>
      <url>/2021/10/28/day1/</url>
      
        <content type="html"><![CDATA[<h2 id="记第一次博客搭建"><a href="#记第一次博客搭建" class="headerlink" title="## 记第一次博客搭建"></a>## 记第一次博客搭建</h2><h1 id="记第一次搭建博客"><a href="#记第一次搭建博客" class="headerlink" title="记第一次搭建博客"></a><strong>记第一次搭建博客</strong></h1><p><strong>引言：</strong></p><ul><li><strong>搭建博客监督我写笔记。</strong></li><li><strong>画面更加炫酷，提升学习兴趣。</strong></li><li><strong>记录每天的心情、感受。</strong></li></ul><p><strong>let’go:</strong></p><p>那就从这里开始吧,哈哈哈，必须得提一下<strong>韩老师</strong>，人长的帅，说话又好听，技术还好~~。</p>        <span class="lazyload-img-span">        <img              data-src="http://tva1.sinaimg.cn/large/006xl9pBly1gvvf7hd0rsj30zk0g6gq8.jpg" >        </sapn>      <p>谈点正经的吧，经过那晚的聊天，我发现韩老师不仅是IT界天花板，而且还有思想。我最喜欢和有思想的人交流。虽然在互联网上我显得很中二，但丝毫无法掩盖我内心的火热以及无数的想法，以及对社会的思考。</p><ul><li>​关于方向：起初我是很好奇为什么，韩老师一个搞IT的天天玩设计，甚至还是视觉中国签约色影师。然后他提到了，是为了多元发展，技术只是一部分，而想要更多的提升，则需要有长远的目光，战略眼光。这一点，我当然很认同，但是我觉得肯定所学的具备相关性啊，所以我的目标是有 技术+思想，编程和电商结合。</li><li>​    战略眼光：他提到了，所学技能和副业差距越大越好，只有这样，才能做出颠覆的举动。韩老师又学法律又学管理学、又学摄影。而我还只局限于IT行业，这一波，我格局小了。</li></ul><h2 id="搭博客遇到的困难"><a href="#搭博客遇到的困难" class="headerlink" title="搭博客遇到的困难"></a>搭博客遇到的困难</h2><p>​博客配置的还是比较艰辛，虽说都是只是无脑配置，可是对于每一台设备，其所面对的Bug都是<strong>不一样滴</strong>。</p><p>学好英语！学好英语！学好英语！重要的事情说三遍。最初是<strong>github关联性</strong>问题，因为未注意到写<strong>仓库地址</strong>的细节，导致后续一直在找哪出错了。之后是发布文章，因为一丢丢格式的细微差距，导致一直报错，迟迟找不出原因。最后是主题更替，官方文档漏了一处细节，我特么。。。</p><h2 id="所得经验"><a href="#所得经验" class="headerlink" title="所得经验"></a>所得经验</h2><ul><li>对于每一篇文档教程，要逐字逐句，不可觉得简单就跳过，因为<strong>Bug</strong>往往就隐藏在这些<strong>小细节</strong>中。</li><li>执行每一个命令之后仔细检查，当前命令是否<strong>successful</strong>，注意：不要报错了，继续执行之后的代码，不然又得抓耳挠腮喽。</li><li>学好英语</li></ul><p>认识了很多学代码的小伙伴、小姐妹，很开心！  <strong>嘿嘿嘿</strong>，冲冲冲 兄弟们。</p><p>别人不给机会，那就自己创造</p><h2 id="因为热爱，所以我无惧一切"><a href="#因为热爱，所以我无惧一切" class="headerlink" title="因为热爱，所以我无惧一切"></a>因为热爱，所以我无惧一切</h2><h2 id="I-will-always-belong-to-my-own！"><a href="#I-will-always-belong-to-my-own！" class="headerlink" title="I will always belong to my own！"></a>I will always belong to my own！</h2>        <span class="lazyload-img-span">        <img              data-src="http://tva1.sinaimg.cn/large/006xl9pBly1gvvfrpn506j30zk0kg783.jpg" >        </sapn>      ]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/03/30/%E5%A4%9A%E6%80%81/"/>
      <url>/2016/03/30/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>#多态笔记</p><h1 id="面向对象多态"><a href="#面向对象多态" class="headerlink" title="面向对象多态"></a><strong>面向对象多态</strong></h1><h2 id="先来看一个问题"><a href="#先来看一个问题" class="headerlink" title="先来看一个问题"></a><strong>先来看一个问题</strong></h2>        <span class="lazyload-img-span">        <img              data-src="https://tva1.sinaimg.cn/large/006xl9pBly1gvw5uxt74vj30r40bw124.jpg" >        </sapn>      <h2 id="首先，使用现有技术解决。"><a href="#首先，使用现有技术解决。" class="headerlink" title="首先，使用现有技术解决。"></a><strong>首先，使用现有技术解决。</strong></h2><p>仅展示部分代码</p><pre><code class="java">package com.hspedu.poly_.poly2;public class Master &#123;    //主人名称    private String name;    public Master(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    //完成主任给小狗 喂食 骨头    public void feed(Dog dog, Food food) &#123;        System.out.println(&quot;主人&quot; + name + &quot;给 &quot; + dog.getName() + &quot;喂食&quot; + food.getName());    &#125;&#125;</code></pre><pre><code class="java">package com.hspedu.poly_.poly2;public class Poly2 &#123;    public static void main(String[] args) &#123;        Master tom = new Master(&quot;tom&quot;);        Dog dog = new Dog(&quot;大黄&quot;);        Bone bone = new Bone(&quot;大骨棒&quot;);        tom.feed(dog,bone);        //现在我还需要一个xxx喂猫吃鱼的方法 该如何实现呢        //难道我需要再写一完成给小猫喂食的方法吗？    &#125;&#125;</code></pre><h2 id="像下面这样"><a href="#像下面这样" class="headerlink" title="像下面这样"></a><strong>像下面这样</strong></h2><pre><code class="java">    public void feed(Cat cat,Fish fish)&#123; //构成方法重载        System.out.println(&quot;主人&quot; + name + &quot;给 &quot; + cat.getName() + &quot;喂食&quot; + fish.getName());    &#125;    // 方法调用        Master bob = new Master(&quot;bob&quot;);        Cat cat = new Cat(&quot;汤姆&quot;);        Fish fish = new Fish(&quot;鱼&quot;);        bob.feed(cat,fish);</code></pre><p>这样的确可以实现此需求，可当我们假设有几百个动物需要喂，难道写几百个吗？</p><p>此时问题就暴露出来了：<strong>代码的复用性不高，而且不利于代码维护</strong></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案</strong>：</h2><p>​引出多态机制：方法或者对象有多种形态。是面向对象的三大特征，多态是建立在封装和继承基础之上的。</p><ul><li><p><strong>方法的多态：重写和重载体现多态</strong></p><pre><code class="java">public class PloyMethod &#123;    public static void main(String[] args) &#123;    //方法重载体现多态        //我们通过不同的参数去调用sum方法,就会去调用不同的方法，因此sum就是多态的体现        A a = new A();        System.out.println(a.sum(10,20));        System.out.println(a.sum(10,20,30));        // 方法重写体现多态  方法名相同，但是只调用自己类的say()方法        B b = new B();        a.say();        b.say();    &#125;&#125;</code></pre></li><li><p><strong>对象的多态 (核心，困难，重点)</strong></p><ul><li><p>一个对象的编译类型和运行类型可以不一致</p></li><li><p>编译类型在定义对象时，就确定了，不能够改变</p></li><li><p>运行类型是可以变化的</p><pre><code class="java">      //animal 编译类型 Animal 运行类型:Dog        Animal animal = new Dog();        animal.cry();        animal = new Cat();        animal.cry();</code></pre></li><li><p>编译类型看等号左边，运行类型看等号右边</p></li></ul></li></ul><h2 id="此时我们再回过头来解决主人喂食问题"><a href="#此时我们再回过头来解决主人喂食问题" class="headerlink" title="此时我们再回过头来解决主人喂食问题"></a>此时我们再回过头来解决主人喂食问题</h2><pre><code class="java">    public void feed(Animal animal, Food food) &#123;        System.out.println(&quot;主人&quot; + name + &quot;在学校里给&quot; + animal.getName() + &quot;喂食&quot; + food.getName());    &#125;</code></pre><h2 id="多态注意事项和细节讨论"><a href="#多态注意事项和细节讨论" class="headerlink" title="多态注意事项和细节讨论"></a>多态注意事项和细节讨论</h2><p>多态的<strong>前提</strong>是：两个对象类存在继承关系</p><p><strong>多态的向上转型：</strong></p><pre><code class="java">Animal animal = new Dog();animal.cry() //找运行类型cry()</code></pre><p><strong>本质</strong>：父类的引用指向了子类的对象</p><p><strong>语法</strong>：父类类型 引用名 &#x3D; new 子类类型();</p><p><strong>特点</strong>：</p><ul><li>编译类看左边 Animal，运行类型看右边 Dog()</li><li>可以调用父类中的所有成员(需要<strong>遵守访问权限</strong>)</li><li>不能调用子类中的<strong>特有成员</strong>（即子类中特有的方法）</li><li>因为编译类型是animal 所以他根本不知道子类方法是谁 所以无法调用</li></ul><pre><code class="java">public class T &#123;    public static void main(String[] args) &#123;        AA aa = new BB();        aa.test();        aa.pp()  // ! 这里会报错 无法调用    &#125;&#125;class AA&#123;    public void test()&#123;        System.out.println(&quot;ok&quot;);    &#125;&#125;class BB extends AA&#123;    public void pp()&#123;        System.out.println(&quot;你好&quot;);    &#125;&#125;</code></pre><ul><li>最终运行效果看子类的具体实现</li></ul><p><strong>多态的向下转型：</strong></p><ul><li><p><strong>语法</strong>: 子类类型 引用名 &#x3D; （子类类型）父类引用</p></li><li><pre><code class="java"> public class T &#123;     public static void main(String[] args) &#123;         AA aa = new BB();         //子类类型 引用名 = （子类类型）父类引用         //bb 原来指向的就是aa对象 才可以向下转型         BB bb = (BB) aa;         bb.pp();     &#125; &#125;  class AA&#123;     public void test()&#123;         System.out.println(&amp;quot;ok&amp;quot;);     &#125; &#125; class BB extends AA&#123;     public void pp()&#123;         System.out.println(&amp;quot;你好&amp;quot;);     &#125; &#125;z</code></pre></li><li><p>只能强转父类的引用，不能强转父类的对象</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象</p></li><li><p>当向下转型后可以调用子类类型中的所有成员</p></li><li><p>​</p><p> <strong>属性不存在重写之说</strong></p><pre><code class="java"></code></pre></li></ul><p>package com.hspedu;</p><pre><code>public class PolyDetail02 &#123;    public static void main(String[] args) &#123;      //属性没有重写之说，属性的值看编译类型        Base base = new Sub(); //向上转型        System.out.println(base.count); //直接看编译类型 10    &#125;&#125;class Base&#123;    int count = 10;&#125;class Sub extends Base&#123;    int count = 20;&#125;</code></pre><p>  instanceOf比较操作符，用于判断<strong>运行类型</strong>是否为XX或者XX<strong>的子类型</strong></p><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 作为日记加密 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
